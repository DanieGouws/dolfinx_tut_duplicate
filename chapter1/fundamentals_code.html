
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Implementation &#8212; FEniCSx tutorial</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Weak imposition of Dirichlet conditions for the Poisson problem" href="nitsche.html" />
    <link rel="prev" title="Solving the Poisson equation" href="fundamentals.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.jpeg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">FEniCSx tutorial</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../index.html">
   The FEniCSx tutorial
  </a>
 </li>
</ul>
<p class="caption" role="heading">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../fem.html">
   An overview of the FEniCS Project
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Changelog.html">
   Changelog
  </a>
 </li>
</ul>
<p class="caption" role="heading">
 <span class="caption-text">
  Fundamentals
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="fundamentals.html">
   Solving the Poisson equation
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Implementation
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="nitsche.html">
   Weak imposition of Dirichlet conditions for the Poisson problem
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="membrane.html">
   Deflection of a membrane
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="membrane_code.html">
     Implementation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="membrane_paraview.html">
     Using Paraview for visualization
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption" role="heading">
 <span class="caption-text">
  A Gallery of finite element solvers
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter2/intro.html">
   A Gallery of finite element solvers
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../chapter2/heat_equation.html">
   The heat equation
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../chapter2/diffusion_code.html">
     Diffusion of a Gaussian function
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../chapter2/heat_code.html">
     A known analytical solution
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../chapter2/nonlinpoisson.html">
   A nonlinear Poisson equation
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../chapter2/nonlinpoisson_code.html">
     Implementation
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../chapter2/linearelasticity.html">
   The equations of linear elasticity
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../chapter2/linearelasticity_code.html">
     Implementation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../chapter2/elasticity_scaling.html">
     Scaling
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../chapter2/navierstokes.html">
   The Navier-Stokes equations
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../chapter2/ns_code1.html">
     Test problem 1: Channel flow (Poiseuille flow)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../chapter2/ns_code2.html">
     Test problem 2: Flow past a cylinder (DFG 2D-3 benchmark)
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter2/hyperelasticity.html">
   Hyperelasticity
  </a>
 </li>
</ul>
<p class="caption" role="heading">
 <span class="caption-text">
  Subdomains and boundary conditions
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter3/neumann_dirichlet_code.html">
   Combining Dirichlet and Neumann conditions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter3/multiple_dirichlet.html">
   Setting multiple Dirichlet condition
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter3/subdomains.html">
   Defining subdomains for different materials
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter3/robin_neumann_dirichlet.html">
   Setting multiple Dirichlet, Neumann, and Robin conditions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter3/component_bc.html">
   Component-wise Dirichlet BC
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter3/em.html">
   Electromagnetics example
  </a>
 </li>
</ul>
<p class="caption" role="heading">
 <span class="caption-text">
  Improving your FEniCSx code
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter4/solvers.html">
   Solver configuration
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter4/compiler_parameters.html">
   JIT Parameters and visualization using Pandas
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter4/convergence.html">
   Error control: Computing convergence rates
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/chapter1/fundamentals_code.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/jorgensd/dolfinx-tutorial"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/jorgensd/dolfinx-tutorial/issues/new?title=Issue%20on%20page%20%2Fchapter1/fundamentals_code.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/jorgensd/dolfinx-tutorial/edit/dokken/jupyterbook/./chapter1/fundamentals_code.ipynb"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/jorgensd/dolfinx-tutorial/dokken/jupyterbook?urlpath=tree/./chapter1/fundamentals_code.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interactive-tutorials">
   Interactive tutorials
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#generating-simple-meshes">
   Generating  simple meshes
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#defining-the-finite-element-function-space">
   Defining the finite element function space
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#defining-the-boundary-conditions">
   Defining the boundary conditions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#defining-the-trial-and-test-function">
   Defining the trial and test function
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#defining-the-source-term">
   Defining the source term
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#defining-the-variational-problem">
   Defining the variational problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#expressing-inner-products">
   Expressing inner products
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#forming-and-solving-the-linear-system">
   Forming and solving the linear system
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#computing-the-error">
   Computing the error
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#plotting-the-solution-using-pyvista">
   Plotting the solution using pyvista
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#interactive-plotting-in-notebooks">
   Interactive plotting in notebooks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#external-post-processing">
   External post-processing
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="implementation">
<h1>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h1>
<p>Author: Jørgen Schartum Dokken</p>
<p>This implementation is an adaptation of the work in <span id="id1">[<a class="reference internal" href="../index.html#id11">LL16</a>]</span> to DOLFINx.</p>
<p>In this section, you will learn:</p>
<ul class="simple">
<li><p>How to use the built-in meshes in DOLFINx</p></li>
<li><p>How to create a Dirichlet boundary conditions on the whole domain boundary</p></li>
<li><p>How to define a weak formulation of your PDE</p></li>
<li><p>How to solve the resulting system of linear equations</p></li>
<li><p>How to visualize the solution using a variety of tools</p></li>
<li><p>How to compute the <span class="math notranslate nohighlight">\(L^2(\Omega)\)</span> error and the error at mesh vertices</p></li>
</ul>
<div class="section" id="interactive-tutorials">
<h2>Interactive tutorials<a class="headerlink" href="#interactive-tutorials" title="Permalink to this headline">¶</a></h2>
<div class="admonition-run-the-tutorial-as-jupyter-notebook-in-browser admonition">
<p class="admonition-title">Run the tutorial as Jupyter notebook in browser</p>
<p>As this book has been published as a Jupyter Book, each code can be run in your browser as a Jupyter notebook. To start such a notebook click the rocket symbol in the top right corner of the relevant tutorial.</p>
</div>
<p>The Poisson problem has so far featured a general domain <span class="math notranslate nohighlight">\(\Omega\)</span> and general functions <span class="math notranslate nohighlight">\(u_D\)</span> for the boundary conditions and <span class="math notranslate nohighlight">\(f\)</span> for the right hand side.
Therefore, we need to make specific choices of <span class="math notranslate nohighlight">\(\Omega, u_D\)</span> and <span class="math notranslate nohighlight">\(f\)</span>. A wise choice is to construct a problem  with a known analytical solution, so that we can check that the computed solution is correct. The primary candidates are lower-order polynomials. The continuous Galerkin finite element spaces of degree <span class="math notranslate nohighlight">\(r\)</span> will exactly reproduce polynomials of degree <span class="math notranslate nohighlight">\(r\)</span>.</p>
<!-- Particularly, piecewise linear continuous Galerkin finite elements are able to exactly reproduce a quadratic polynomial on 
a uniformly partitioned mesh. -->
<p>We use this fact to construct a quadratic function in <span class="math notranslate nohighlight">\(2D\)</span>. In particular we choose</p>
<div class="amsmath math notranslate nohighlight" id="equation-824a8d0a-9bd6-46c5-96d8-1f76202d7db6">
<span class="eqno">(6)<a class="headerlink" href="#equation-824a8d0a-9bd6-46c5-96d8-1f76202d7db6" title="Permalink to this equation">¶</a></span>\[\begin{align}
 u_e(x,y)=1+x^2+2y^2
 \end{align}\]</div>
<p>Inserting <span class="math notranslate nohighlight">\(u_e\)</span> in the original boundary problem, we find that</p>
<div class="amsmath math notranslate nohighlight" id="equation-f04a5961-761f-4513-b38e-770bb24b47e8">
<span class="eqno">(7)<a class="headerlink" href="#equation-f04a5961-761f-4513-b38e-770bb24b47e8" title="Permalink to this equation">¶</a></span>\[\begin{align}
    f(x,y)= -6,\qquad u_d(x,y)=u_e(x,y)=1+x^2+2y^2,
\end{align}\]</div>
<p>regardless of the shape of the domain as long as we prescribe
<span class="math notranslate nohighlight">\(u_e\)</span> on the boundary.</p>
<p>For simplicity, we choose the domain to be a unit square <span class="math notranslate nohighlight">\(\Omega=[0,1]\times [0,1]\)</span></p>
<p>This simple but very powerful method for constructing test problems is called <em>the method of manufactured solutions</em>.
First pick a simple expression for the exact solution, plug into
the equation to obtain the right-hand side (source term <span class="math notranslate nohighlight">\(f\)</span>). Then solve the equation with this right hand side, and using the exact solution as boundary condition. Finally, we create a program that tries to reproduce the exact solution.</p>
<p>Note that in many cases, it can be hard to determine if the program works if it produces an error of size <span class="math notranslate nohighlight">\(10^{-5}\)</span> on a
<span class="math notranslate nohighlight">\(20 \times 20\)</span> grid. However, since we are using Sobolev spaces,
we usually know about the numerical errors <em>asymptotic properties</em>. For instance that it is proportional to <span class="math notranslate nohighlight">\(h^2\)</span> if <span class="math notranslate nohighlight">\(h\)</span> is the size of a cell in the mesh. We can then compare the error on meshes with different <span class="math notranslate nohighlight">\(h\)</span>-values to see if the asymptotic behavior is correct. This technique will be explained in detail in the chapter <a class="reference internal" href="../chapter4/convergence.html"><span class="doc std std-doc">Improving your fenics code</span></a>.</p>
<p>However, in cases where we have a solution we know that should have no approximation error, we know that the solution should
be produced to machine precision by the program.</p>
<p>The first eight lines of the program are importing the different modules required for solving the problem.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dolfinx</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">ufl</span>
<span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
</pre></div>
</div>
</div>
</div>
<p>A major difference between a traditional FEniCS code and a FEniCSx code, is that one is not advised to use the wildcard import.</p>
</div>
<div class="section" id="generating-simple-meshes">
<h2>Generating  simple meshes<a class="headerlink" href="#generating-simple-meshes" title="Permalink to this headline">¶</a></h2>
<p>The next step is to define the discrete domain, <em>the mesh</em></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span> <span class="o">=</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">cpp</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">CellType</span><span class="o">.</span><span class="n">quadrilateral</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>which defines a uniform finite element mesh over the unit square <span class="math notranslate nohighlight">\([0,1]\times[0, 1]\)</span>. The mesh consists of <em>cells</em>, which in 2D can be either triangles of quadrilaterals. Note that in addition to give how many elements we would like to have in each direction.
Note that we also supply the <em>MPI-communicator</em>.
This is to specify how we would like the program to behave in parallel. If we supply <code class="docutils literal notranslate"><span class="pre">MPI.COMM_WORLD</span></code> we create a single mesh,
whose data is distributed over the number of processors we
would like to use. We can for instance run the program in
parallel on two processors by using <code class="docutils literal notranslate"><span class="pre">mpirun</span></code>, as:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span> mpirun -n <span class="m">2</span> python3 t1.py
</pre></div>
</div>
<p>However, if we would like to create a separate mesh on each processor, we can use <code class="docutils literal notranslate"><span class="pre">MPI.COMM_SELF</span></code>. This is for instance
useful if we run a small problem, and would like to run it with
multiple parameters.</p>
</div>
<div class="section" id="defining-the-finite-element-function-space">
<h2>Defining the finite element function space<a class="headerlink" href="#defining-the-finite-element-function-space" title="Permalink to this headline">¶</a></h2>
<p>Once the mesh has been created, we can create the finite element function space <span class="math notranslate nohighlight">\(V\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span> <span class="n">V</span> <span class="o">=</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>The second argument is the tuple containing the type of finite element, and the element degree. The type of element here is “CG”, which implies the standard Lagrange family of elements.
DOLFINx supports a large variety on elements on simplices
(triangles and tetrahedra) and non-simplices (quadrilaterals
and hexahedra). For an overview, see:
<em>FIXME: Add link to all the elements we support</em></p>
<p>The element degree in the code is 1. This means that we are choosing the standard <span class="math notranslate nohighlight">\(P_1\)</span> linear Lagrange element, which has degrees of freedom at the vertices. The computed solution will be continuous across elements and linearly varying in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> inside each element. Higher degree polynomial approximations are obtained by increasing the degree argument.</p>
</div>
<div class="section" id="defining-the-boundary-conditions">
<h2>Defining the boundary conditions<a class="headerlink" href="#defining-the-boundary-conditions" title="Permalink to this headline">¶</a></h2>
<p>The next step is to specify the boundary condition <span class="math notranslate nohighlight">\(u=u_D\)</span> on <span class="math notranslate nohighlight">\(\partial\Omega_D\)</span>, which is done by over several steps. The first step is to define the function <span class="math notranslate nohighlight">\(u_D\)</span>. Into this function, we would like to interpolate the boundary condition <span class="math notranslate nohighlight">\(1 + x^2+2y^2\)</span>. We do this by first defining a <code class="docutils literal notranslate"><span class="pre">dolfinx.Function</span></code>, and then using a <a class="reference external" href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions">lambda-function</a> in Python to define the
spatially varying function. As we would like this program to work on one or multiple processors, we have to update the coefficients of <span class="math notranslate nohighlight">\(u_D\)</span> that data shared between the processors. We do this by sending (scattering) the ghost values in the underlying data structure of <code class="docutils literal notranslate"><span class="pre">uD</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">uD</span> <span class="o">=</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">uD</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">uD</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">scatter_forward</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We now have the boundary data (and in this case the solution of
the finite element problem) represented in the discrete function space.
Next we would like to apply the boundary values to all degrees of freedom that are on the boundary of the discrete domain. We start by identifying the facets (line-segments) representing the outer boundary, using <code class="docutils literal notranslate"><span class="pre">dolfinx.cpp.mesh.compute_boundary_facets</span></code>.
This function returns an array of booleans of the same size as the number of facets on this processor, where <code class="docutils literal notranslate"><span class="pre">True</span></code> indicates that the local facet <span class="math notranslate nohighlight">\(i\)</span> is on the boundary. To reduce this to only the indices that are <code class="docutils literal notranslate"><span class="pre">True</span></code>, we use <code class="docutils literal notranslate"><span class="pre">numpy.where</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fdim</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span>
<span class="c1"># Create facet to cell connectivity required to determine boundary facets</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">create_connectivity</span><span class="p">(</span><span class="n">fdim</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
<span class="n">boundary_facets</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">cpp</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">compute_boundary_facets</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>For the current problem, as we are using the “CG” 1 function space, the degrees of freedom are located at the vertices of each cell, thus each facet contains two degrees of freedom.</p>
<p>To find the local indices of these degrees of freedom, we use <code class="docutils literal notranslate"><span class="pre">dolfinx.fem.locate_dofs_topological</span></code>, which takes in the function space, the dimension of entities in the mesh we would like to identify and the local entities.</p>
<div class="admonition-local-ordering-of-degrees-of-freedom-and-mesh-vertices admonition">
<p class="admonition-title">Local ordering of degrees of freedom and mesh vertices</p>
<p>Many people expect there to be a 1-1 correspondence between the mesh coordinates and the coordinates of the degrees of freedom.
However, this is only true in the case of <code class="docutils literal notranslate"><span class="pre">CG</span></code> 1 elements on a first order mesh. Therefore, in DOLFINx we use separate local numbering for the mesh coordinates and the dof coordinates. To obtain the local dof coordinates we can use <code class="docutils literal notranslate"><span class="pre">V.tabulate_dof_coordinates()</span></code>, while the ordering of the local vertices can be obtained by <code class="docutils literal notranslate"><span class="pre">mesh.geometry.x</span></code>.</p>
</div>
<p>With this data at hand, we can create the Dirichlet boundary condition</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">boundary_dofs</span> <span class="o">=</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">locate_dofs_topological</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">fdim</span><span class="p">,</span> <span class="n">boundary_facets</span><span class="p">)</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">uD</span><span class="p">,</span> <span class="n">boundary_dofs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="defining-the-trial-and-test-function">
<h2>Defining the trial and test function<a class="headerlink" href="#defining-the-trial-and-test-function" title="Permalink to this headline">¶</a></h2>
<p>In mathematics, we distinguish between trial and test spaces <span class="math notranslate nohighlight">\(V\)</span> and <span class="math notranslate nohighlight">\(\hat{V}\)</span>. The only difference in the present problem is the boundary conditions.
In FEniCSx, we do not specify boundary conditions as part of the function space, so it is sufficient to use a common space for the trial and test function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="defining-the-source-term">
<h2>Defining the source term<a class="headerlink" href="#defining-the-source-term" title="Permalink to this headline">¶</a></h2>
<p>As the source term is constant over the domain, we use <code class="docutils literal notranslate"><span class="pre">dolfinx.Constant</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition-compilation-speed-up admonition">
<p class="admonition-title">Compilation speed-up</p>
<p>Instead of wrapping <span class="math notranslate nohighlight">\(-6\)</span> in a <code class="docutils literal notranslate"><span class="pre">dolfinx.Constant</span></code>, we could simply define <span class="math notranslate nohighlight">\(f\)</span> as <code class="docutils literal notranslate"><span class="pre">f=-6</span></code>.
However, if we would like to change this parameter later in the simulation, we would have to redefine our variational formulation. The <code class="docutils literal notranslate"><span class="pre">dolfinx.Constant</span></code> allows us to update the value in <span class="math notranslate nohighlight">\(f\)</span> by using <code class="docutils literal notranslate"><span class="pre">f.value=5</span></code>. Additionally, by indicating that <span class="math notranslate nohighlight">\(f\)</span> is a constant, we speed of compilation of the variational formulations required for the created linear system.</p>
</div>
</div>
<div class="section" id="defining-the-variational-problem">
<h2>Defining the variational problem<a class="headerlink" href="#defining-the-variational-problem" title="Permalink to this headline">¶</a></h2>
<p>As we now have defined all variables used to describe our variational problem, we can create the weak formulation</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">ufl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span>
</pre></div>
</div>
</div>
</div>
<p>Note that there is a very close correspondence between the Python syntax and the mathematical syntax
<span class="math notranslate nohighlight">\(\int_{\Omega} \nabla u \cdot \nabla v ~\mathrm{d} x\)</span> and <span class="math notranslate nohighlight">\(\int_{\Omega}fv~\mathrm{d} x\)</span>.
The integration over the domain <span class="math notranslate nohighlight">\(\Omega\)</span> is defined by using <code class="docutils literal notranslate"><span class="pre">ufl.dx</span></code>, an integration measure over all cells of the mesh.</p>
<p>This is the key strength of FEniCSx: the formulas in the variational formulation translate directly to very similar Python code, a feature that makes it easy to specify and solve complicated PDE problems. The language used to express weak forms is the Unified Form Language <a class="reference external" href="https://doi.org/10.1145/2566630">UFL</a>.</p>
</div>
<div class="section" id="expressing-inner-products">
<h2>Expressing inner products<a class="headerlink" href="#expressing-inner-products" title="Permalink to this headline">¶</a></h2>
<p>The inner product <span class="math notranslate nohighlight">\(\int_\Omega \nabla u \cdot \nabla v ~\mathrm{d} x\)</span> can be expressed in various ways in UFL. We have used the notation <code class="docutils literal notranslate"><span class="pre">ufl.dot(ufl.grad(u),</span> <span class="pre">ufl.grad(v))*uf.dx</span></code>. The dot product in UFL computes the sum (contraction) over the last index of the first factor and first index of the second factor. In this case, both factors are tensors of rank one (vectors) and so the sum is just over the single index of both <span class="math notranslate nohighlight">\(\nabla u\)</span> and <span class="math notranslate nohighlight">\(\nabla v\)</span>. To compute an inner product of matrices (with two indices), one must instead of <code class="docutils literal notranslate"><span class="pre">ufl.dot</span></code> use the function <code class="docutils literal notranslate"><span class="pre">ufl.inner</span></code>. For vectors, <code class="docutils literal notranslate"><span class="pre">ufl.dot</span></code> and <code class="docutils literal notranslate"><span class="pre">ufl.inner</span></code> are equivalent.</p>
</div>
<div class="section" id="forming-and-solving-the-linear-system">
<h2>Forming and solving the linear system<a class="headerlink" href="#forming-and-solving-the-linear-system" title="Permalink to this headline">¶</a></h2>
<p>Having defined the finite element variational problem and boundary condition, we can create our <code class="docutils literal notranslate"><span class="pre">dolfinx.fem.LinearProblem</span></code>, as class for solving
the variational problem: Find <span class="math notranslate nohighlight">\(u_h\in V\)</span> such that <span class="math notranslate nohighlight">\(a(u_h, v)==L(v) \quad \forall v \in \hat{V}\)</span>. We will use PETSc as our linear algebra backend, using a direct solver (LU-factorization).  See the <a class="reference external" href="https://petsc.org/main/docs/manual/ksp/?highlight=ksp#ksp-linear-system-solvers">PETSc-documentation</a> of the method for more information.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">problem</span> <span class="o">=</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">LinearProblem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bc</span><span class="p">],</span> <span class="n">petsc_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;preonly&quot;</span><span class="p">,</span> <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;lu&quot;</span><span class="p">})</span>
<span class="n">uh</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Using <code class="docutils literal notranslate"><span class="pre">problem.solve()</span></code> we solve the linear system of equations and return a <code class="docutils literal notranslate"><span class="pre">dolfinx.Function</span></code> containing the solution.</p>
</div>
<div class="section" id="computing-the-error">
<h2>Computing the error<a class="headerlink" href="#computing-the-error" title="Permalink to this headline">¶</a></h2>
<p>Finally, we want to compute the error to check the accuracy of the solution. We do this by comparing the finite element solution <code class="docutils literal notranslate"><span class="pre">u</span></code> with the exact solution. We do this by interpolating the exact solution into the the <span class="math notranslate nohighlight">\(P_2\)</span>-function space.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">V2</span> <span class="o">=</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">uex</span> <span class="o">=</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span>
<span class="n">uex</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">uex</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">scatter_forward</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We compute the error in two different ways. First, we compute the <span class="math notranslate nohighlight">\(L^2\)</span>-norm of the error, defined by <span class="math notranslate nohighlight">\(E=\sqrt{\int_\Omega (u_D-u_h)^2\mathrm{d} x}\)</span>. We use UFL to express the <span class="math notranslate nohighlight">\(L^2\)</span>-error:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">L2_error</span> <span class="o">=</span> <span class="n">ufl</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">uh</span> <span class="o">-</span> <span class="n">uex</span><span class="p">,</span> <span class="n">uh</span> <span class="o">-</span> <span class="n">uex</span><span class="p">)</span> <span class="o">*</span> <span class="n">ufl</span><span class="o">.</span><span class="n">dx</span>
<span class="n">error_L2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dolfinx</span><span class="o">.</span><span class="n">fem</span><span class="o">.</span><span class="n">assemble_scalar</span><span class="p">(</span><span class="n">L2_error</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Secondly, we compute the maximum error at any degree of freedom.
As the finite element function <span class="math notranslate nohighlight">\(u\)</span> can be expressed as a linear combination of basis functions <span class="math notranslate nohighlight">\(\phi_j\)</span>, spanning the space <span class="math notranslate nohighlight">\(V\)</span>:
<span class="math notranslate nohighlight">\( u = \sum_{j=1}^N U_j\phi_j.\)</span>
By writing <code class="docutils literal notranslate"><span class="pre">problem.solve()</span></code> we compute all the coefficients <span class="math notranslate nohighlight">\(U_1,\dots, U_N\)</span>. These values are known as the <em>degrees of freedom</em> (dofs). We can access the degrees of freedom by accessing the underlying vector in <code class="docutils literal notranslate"><span class="pre">uh</span></code>.
However, as a second order function space has more dofs than a linear function space, we cannot compare these arrays directly.
Therefore we compute the values of both <code class="docutils literal notranslate"><span class="pre">uex</span></code> and <code class="docutils literal notranslate"><span class="pre">uD</span></code> at the mesh nodes (for a linear mesh this is the vertices).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">u_vertex_values</span> <span class="o">=</span> <span class="n">uh</span><span class="o">.</span><span class="n">compute_point_values</span><span class="p">()</span>
<span class="n">u_ex_vertex_values</span> <span class="o">=</span> <span class="n">uex</span><span class="o">.</span><span class="n">compute_point_values</span><span class="p">()</span>
<span class="n">error_max</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_vertex_values</span> <span class="o">-</span> <span class="n">u_ex_vertex_values</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error_L2 : </span><span class="si">{</span><span class="n">error_L2</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error_max : </span><span class="si">{</span><span class="n">error_max</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Error_L2 : 8.24e-03
Error_max : 2.22e-15
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="plotting-the-solution-using-pyvista">
<h2>Plotting the solution using pyvista<a class="headerlink" href="#plotting-the-solution-using-pyvista" title="Permalink to this headline">¶</a></h2>
<p>Once the solution has been computed, we will visualize it using <a class="reference external" href="https://docs.pyvista.org/">pyvista</a>, an interface to the VTK toolkit.
We start by converting the mesh to a format that can be used with <code class="docutils literal notranslate"><span class="pre">pyvista</span></code>.
To do this we use the function <code class="docutils literal notranslate"><span class="pre">dolfinx.plot.create_vtk_topology</span></code>. The first step is to create an unstructured grid that can be used by <code class="docutils literal notranslate"><span class="pre">pyvista</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dolfinx.plot</span>
<span class="n">topology</span><span class="p">,</span> <span class="n">cell_types</span> <span class="o">=</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">create_vtk_topology</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyvista</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">UnstructuredGrid</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">cell_types</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we attach data from our solution <code class="docutils literal notranslate"><span class="pre">uh</span></code> by computing the values of the function at each vertex.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">uh</span><span class="o">.</span><span class="n">compute_point_values</span><span class="p">()</span><span class="o">.</span><span class="n">real</span>
<span class="n">grid</span><span class="o">.</span><span class="n">set_active_scalars</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can now use the <code class="docutils literal notranslate"><span class="pre">pyvista.Plotter</span></code> to visualize the solution. We visualize it by showing it in 2D and warped in 3D.
In the jupyter notebook environment, we use the default setting of <code class="docutils literal notranslate"><span class="pre">pyvista.OFF_SCREEN=False</span></code>, which will render plots directly in the notebook. . PYVITo render in the online notebooks or in docker containers without X-forwarding, we need to start a virtual framebuffer.</p>
<div class="admonition-rendering-with-pyvista-using-docker-containers admonition">
<p class="admonition-title">Rendering with pyvista using Docker-containers</p>
<p>To make the plots render, we have to call <code class="docutils literal notranslate"><span class="pre">pyvista.start_xvfb</span></code> to start a virtual framebuffer if using docker-containers or jupyter notebooks on Linux.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pyvista</span><span class="o">.</span><span class="n">start_xvfb</span><span class="p">(</span><span class="n">wait</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">plotter</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">Plotter</span><span class="p">()</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">show_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_scalar_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_xy</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">OFF_SCREEN</span><span class="p">:</span>
    <span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">figure</span> <span class="o">=</span> <span class="n">plotter</span><span class="o">.</span><span class="n">screenshot</span><span class="p">(</span><span class="s2">&quot;fundamentals.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/fundamentals_code_32_0.png" src="../_images/fundamentals_code_32_0.png" />
</div>
</div>
</div>
<div class="section" id="interactive-plotting-in-notebooks">
<h2>Interactive plotting in notebooks<a class="headerlink" href="#interactive-plotting-in-notebooks" title="Permalink to this headline">¶</a></h2>
<p>To create an interactive plot using pyvista in a Jupyter notebook we us <code class="docutils literal notranslate"><span class="pre">pyvista.ITKPlotter</span></code> which uses <code class="docutils literal notranslate"><span class="pre">itkwidgets</span></code>. To modify the visualization, click on the three bars in the top left corner.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="ow">not</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">OFF_SCREEN</span><span class="p">:</span>
    <span class="n">plotter_itk</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PlotterITK</span><span class="p">()</span>
    <span class="n">warped</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">warp_by_scalar</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">plotter_itk</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">warped</span><span class="p">)</span>
    <span class="n">plotter_itk</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"version_major": 2, "version_minor": 0, "model_id": "86b513883afb4b9492398bc41f2b5589"}
</script></div>
</div>
</div>
<div class="section" id="external-post-processing">
<h2>External post-processing<a class="headerlink" href="#external-post-processing" title="Permalink to this headline">¶</a></h2>
<p>For post-processing outside the python code, it is suggested to save the solution to file using either <code class="docutils literal notranslate"><span class="pre">dolfinx.io.VTKFile</span></code> or <code class="docutils literal notranslate"><span class="pre">dolfinx.io.XDMFFile</span></code> and using <a class="reference external" href="https://www.paraview.org/">Paraview</a>. This ifs especially suggested for 3D visualization.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dolfinx.io</span>
<span class="k">with</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">VTKFile</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="s2">&quot;output.pvd&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">vtk</span><span class="p">:</span>
    <span class="n">vtk</span><span class="o">.</span><span class="n">write</span><span class="p">([</span><span class="n">uh</span><span class="o">.</span><span class="n">_cpp_object</span><span class="p">])</span>
<span class="k">with</span> <span class="n">dolfinx</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">XDMFFile</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="s2">&quot;output.xdmf&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">xdmf</span><span class="p">:</span>
    <span class="n">xdmf</span><span class="o">.</span><span class="n">write_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">xdmf</span><span class="o">.</span><span class="n">write_function</span><span class="p">(</span><span class="n">uh</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2021-10-29 08:02:01.455 (   6.318s) [main            ]            VTKFile.cpp:617   WARN| Output data is interpolated into a first order Lagrange space.
</pre></div>
</div>
</div>
</div>
<span class="target" id="id2"></span></div>
</div>


<script type="application/vnd.jupyter.widget-state+json">
{"state": {"5a5fd1f3ab6f4f2a9d441d1f52be6d48": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "86b513883afb4b9492398bc41f2b5589": {"model_name": "ViewerModel", "model_module": "itkwidgets", "model_module_version": "^0.32.1", "state": {"_custom_cmap": null, "_dom_classes": [], "_downsampling": false, "_largest_roi": {"shape": [2, 3], "dtype": "float64"}, "_model_module": "itkwidgets", "_model_module_version": "^0.32.1", "_model_name": "ViewerModel", "_rendering_image": false, "_reset_crop_requested": false, "_scale_factors": {"shape": [3], "dtype": "uint8"}, "_view_count": null, "_view_module": "itkwidgets", "_view_module_version": "^0.32.1", "_view_name": "ViewerView", "annotations": true, "axes": false, "background": [], "blend_mode": "composite", "camera": {"shape": [3, 3], "dtype": "float32"}, "channels": null, "clicked_slice_point": null, "cmap": null, "geometries": [{"vtkClass": "vtkPolyData", "points": {"vtkClass": "vtkPoints", "name": "_points", "numberOfComponents": 3, "dataType": "Float32Array", "size": 243}, "polys": {"vtkClass": "vtkCellArray", "name": "_polys", "numberOfComponents": 1, "size": 320, "dataType": "Uint32Array"}, "pointData": {"vtkClass": "vtkDataSetAttributes", "activeScalars": 0, "arrays": [{"data": {"vtkClass": "vtkDataArray", "name": "u", "numberOfComponents": 1, "size": 81, "dataType": "Float64Array"}}]}, "metadata": {"name": "Geometry 0"}}], "geometry_colors": {"shape": [1, 3], "dtype": "float32"}, "geometry_opacities": {"shape": [1], "dtype": "float32"}, "gradient_opacity": 0.2, "interpolation": true, "label_image_blend": 0.5, "label_image_names": null, "label_image_weights": null, "layout": "IPY_MODEL_5a5fd1f3ab6f4f2a9d441d1f52be6d48", "lut": "glasbey", "mode": "v", "opacity_gaussians": null, "point_set_colors": {"shape": [0, 3], "dtype": "float32"}, "point_set_opacities": {"shape": [0], "dtype": "float32"}, "point_set_representations": [], "point_set_sizes": {"shape": [0], "dtype": "uint8"}, "point_sets": [], "rendered_image": null, "rendered_label_image": null, "roi": {"shape": [2, 3], "dtype": "float64"}, "rotate": false, "sample_distance": 0.25, "select_roi": false, "shadow": true, "slicing_planes": false, "ui_collapsed": true, "units": "", "vmax": null, "vmin": null, "x_slice": null, "y_slice": null, "z_slice": null}, "buffers": [{"data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", "encoding": "base64", "path": ["_largest_roi", "buffer"]}, {"data": "AQEB", "encoding": "base64", "path": ["_scale_factors", "buffer"]}, {"data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", "encoding": "base64", "path": ["camera", "buffer"]}, {"data": "KLUv/WDMAl0KAGKIHihQV6EDsNhZIbVcH2iRHey8K/cO3sJzW1rlnNWjkjJV3qWtQQFBaQ1T+Q8IfAeCb8EjfL0Nh6/ixp9AfBeXQQYI2fJHHN+HBDSeKobynXwaUewjfjMiR7YidTwhU43V8fM0KqFsf7pULRzs+6S9dDkLPzy3+9zcsvIBgJaoAJtiDrACIankBhCAMusYy4vcxIrHvqGFtgMYtnT+cRepODAM+gTL+/x+eCMF8rddnVP9QC3JTidGP0skDOadWQ0v5y+il8fQP0I+J88WVvjXpg4+98eFBXVm5n7WzXCK/53vOvCG4PNpaEQfi7tTVa8jzBDevfeN06mLfZyf8p7fdxJGyka44tAPxsc/vq74H1w85Jeqq/WVizL+/utxdlmyGz0ZS/+zJedf09fnx2UNcyzfzrv61TkzO0KHU/xtC27j1Ie53OL5GBI=", "encoding": "base64", "path": ["geometries", 0, "points", "compressedValues"]}, {"data": "KLUv/WAABH0MAGIIGQwQ4NMYwMt+9NUWbyl/+qPH1FhEiUNhEPjz/dv7l3fuqi6H+/dmq9HqTGbGYOfL1aqslSqFOv2mEmkkMkOgz+/pcDaaDObyWyqUiSQC+R+OBmNRKv4E4mAo/CVhINgf8Ad+8g2A46hQ2bJnIALinNkDEKCBtDXPe670tHvIzV424LDcE3s3y57bO1hoaNdvvl3aisN3Y7Zy8NGIfYfvxmzlYKYV+w7zrVl+zK3aP7Nr8HV/Pv/fOfhe92F/8HM/jEWUj4Pf+jp+8PuexwN/8yQtb2Iyeu4+qb/OG53w13Wb7uvcyAl8XW9iYnpY2sRndIoj/9C3600n/ue+GZPoc9qICXRdbWJiem6bMYk+p434QHdLm3ST5SMW7nl72A8+bg/7oeftsD/83B7mh56bw1ikjxUOcf/d7Ubv2/n1fBzOXNf1MueKP8d57uhhYZZb2ZPGux9+vODH8fsVPW9fr/tl8ZO72Imeu09dPMALbVl+FY6hdGQ7vY+8OecDX0F4YiFH6MPyX2N8d6pgBw==", "encoding": "base64", "path": ["geometries", 0, "polys", "compressedValues"]}, {"data": "KLUv/WCIAUUIAMLLJCOgpelEyDctKB36oaoeraoqcPif9++Cf1WA/T9v25KR3mTvFCbIzEzJjI9JpgWHyY2vzUDjINTnjmPwg54afhBRR9jMI5YhiODEmaVbV0jvdITKB01g1MQTqlNU6+mFpTM8/XhfIMdwva2nCuOFpbGuZSFbkuPsh1kzrrhhaeqFEpRDHsF1gTzA+wAlM3N60tq2AU6oQVBZeX8D0KIxswMQQOTaAaOjtedb4lSCWbNBmX+XRy5+Gzuh4xlNmDXd4tZ6SLxpNvZix+k/af9O+6hh2GXGZmF5uRZ6VzzQxk5MLqhsTPNmmW2rpmoF59AC+1jLmaXuHJrbw3/kbFr/Vk3kpX+ZVQ==", "encoding": "base64", "path": ["geometries", 0, "pointData", "arrays", 0, "data", "compressedValues"]}, {"data": "AACAPwAAgD8AAIA/", "encoding": "base64", "path": ["geometry_colors", "buffer"]}, {"data": "AACAPw==", "encoding": "base64", "path": ["geometry_opacities", "buffer"]}, {"data": "", "encoding": "base64", "path": ["point_set_colors", "buffer"]}, {"data": "", "encoding": "base64", "path": ["point_set_opacities", "buffer"]}, {"data": "", "encoding": "base64", "path": ["point_set_sizes", "buffer"]}, {"data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", "encoding": "base64", "path": ["roi", "buffer"]}]}}, "version_major": 2, "version_minor": 0}
</script>


    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./chapter1"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="fundamentals.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">Solving the Poisson equation</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="nitsche.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">Weak imposition of Dirichlet conditions for the Poisson problem</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Jørgen S. Dokken<br/>
        
            &copy; Copyright 2021.<br/>
          <div class="extra_footer">
            <div>
    This webpage is an adaptation of <a href=https://www.springer.com/gp/book/9783319524610>The FEniCS tutorial</a> and
    is distributed under the terms of the      <a href=http://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0 International License  </a>
    which permits use, duplication, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source,
    provide a link to the Creative Commons license and indicate if changes were made.
</div>

          </div>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>